<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CSS Container Queries</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="description" content="In a discussion on GitHub I came up with the idea of a slightly different syntax and function for container queries which I want to explain in more detail here. Container Queries are a concept described by Mat Marquis on A List Apart as an evolution of element queries. If you want to know more about container queries in general, take a look at the RICG repositories on GitHub: container-queries, cq-demos and cq-usecases.">
<style>html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,footer,header{display:block}a{background-color:transparent}a:active,a:hover{outline:0}img{border:0}pre{overflow:auto}code,pre{font-family:monospace;font-size:1em}html{box-sizing:border-box;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font:87.5%/1.5 sans-serif;letter-spacing:.02em;color:#000}@media (min-width:600px){html{font-size:100%}}@media (min-width:800px){html{font-size:112.5%}}@media (min-width:1000px){html{font-size:125%}}*,:after,:before{box-sizing:inherit}h1,h2,h3{margin:1.5em 0 .5em;font-family:Georgia,serif}h1,h2{line-height:1.2}h1{font-size:1.75em}h2{font-size:1.25em}h3{font-size:1.1em}p{margin:1em 0}a{color:#2d7ab3;text-decoration:none}a:visited{color:#882db3}a:focus,a:hover{color:#2d7ab3;text-decoration:underline}code,pre{border-radius:.2em;color:#fff;background:#000}code{padding:.1em .3em;font-size:.9em}pre{padding:.5em .75em;-webkit-overflow-scrolling:touch}pre>code{padding:0}.page{max-width:35em;margin:0 auto;padding:1em 2em}.post{padding-bottom:3em;border-bottom:2px solid #ccc}.post-header{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:baseline;-webkit-align-items:baseline;-ms-flex-align:baseline;align-items:baseline;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between}.post-date{min-width:4em;margin-left:1em;text-align:right}.post-date>a{color:inherit}.post-date>a:focus,.post-date>a:hover{color:#2d7ab3;text-decoration:none}.profile{margin:4em 0 2em;text-align:center;font-size:.8em}.profile-image{display:block;margin:0 auto;width:70px;border:3px solid transparent;border-radius:99em;overflow:hidden;background:-webkit-radial-gradient(31px,#000 97%,transparent 100%) no-repeat;background:radial-gradient(31px,#000 97%,transparent 100%) no-repeat}.profile-image:focus,.profile-image:hover{border-color:#2d7ab3}.profile-image>img{display:block;width:4pc;height:4pc}.profile>h3{margin:1em 0 0}.profile>p{margin:.5em 0 0}.profile a{color:inherit}.profile a:focus,.profile a:hover{color:#2d7ab3;text-decoration:none}.token.punctuation{color:#f8f8f2}.token.property{color:#f92672}.token.selector{color:#a6e22e}</style>
<link rel="canonical" href="https://au.si/css-container-queries">
<link rel="icon" href="/images/profile-64.jpg" type="image/jpeg">
</head>
<body>
<div class="page h-entry">
<article class="post">
<header class="post-header">
<h1 class="post-headline p-name">CSS Container Queries</h1>
<time class="post-date dt-published" datetime="2015-08-01"><a class="u-url" href="/css-container-queries">1 Aug 2015</a></time>
</header>
<div class="e-content">
<p>In a <a href="https://github.com/ResponsiveImagesCG/container-queries/issues/2#issuecomment-121281825">discussion on GitHub</a> I came up with the idea of a slightly different syntax and function for container queries which I want to explain in more detail here. Container Queries are a concept described by <a href="http://alistapart.com/author/matmarquis">Mat Marquis</a> on <a href="http://alistapart.com/article/container-queries-once-more-unto-the-breach">A List Apart</a> as an evolution of element queries. If you want to know more about container queries in general, take a look at the <a href="http://ricg.io/">RICG</a> repositories on GitHub: <a href="https://github.com/ResponsiveImagesCG/container-queries">container-queries</a>, <a href="https://github.com/ResponsiveImagesCG/cq-demos">cq-demos</a> and <a href="https://github.com/ResponsiveImagesCG/cq-usecases">cq-usecases</a>.</p>
<h2 id="the-recursion-issue">The Recursion Issue</h2>
<p>The main problem with container queries is recursion or circularity, think of the following example:</p>
<pre><code class="lang-css"><span class="token selector" >.container</span> <span class="token punctuation" >{</span> <span class="token property" >float</span><span class="token punctuation" >:</span> left<span class="token punctuation" >;</span> <span class="token punctuation" >}</span>
<span class="token selector" >.child</span> <span class="token punctuation" >{</span> <span class="token property" >width</span><span class="token punctuation" >:</span> 200px<span class="token punctuation" >;</span> <span class="token punctuation" >}</span>
<span class="token selector" >.container:media(min-width: 150px) .child</span> <span class="token punctuation" >{</span> <span class="token property" >width</span><span class="token punctuation" >:</span> 100px<span class="token punctuation" >;</span> <span class="token punctuation" >}</span>
</code></pre>
<p>The width of the container depends on the width of its descendants and because of that, the CSS above cannot be handled correctly. The second rule sets the width of the child to 200 and therefore the third rule would match, this would set the width to 100 and the third rule wouldn’t match anymore which sets it back to 200 and so on.</p>
<h2 id="browser-implementation-problems">Browser Implementation Problems</h2>
<p>Another problem is how browsers work with CSS. They mainly go through three steps: compute style, layout and paint. In the first step all style rules are matched against all elements on the page to get the CSS properties for each of them. In the second step the dimensions and positions of all elements are calculated and in the final step everything gets painted on the screen.</p>
<p>The problem is that for container queries we need to know the size of an element – which is calculated in step 2 – to know which rules should match in step 1. Going back and forth between compute style and layout and detecting recursions in this process may be very complex and bad for performance.</p>
<h2 id="solutions-">Solutions?</h2>
<p><a href="http://www.xanthir.com/">Tab Atkins</a> wrote about a possible solution in <a href="http://www.xanthir.com/b4VG0">this article</a>, describing a concept of “viewport elements” which work similar to iframes. If I understand it correctly, it would mean that width and height have to be fixed which wouldn’t be great for most use cases. Fixed width and dynamic height are what most use cases are about I think.</p>
<h2 id="different-syntax">Different Syntax</h2>
<p>With container queries working a bit different than the current proposal, it might be possible to solve the issues. I thought of the following syntax:</p>
<pre><code class="lang-css"><span class="token selector" >.child:container(min-width: 150px)</span> <span class="token punctuation" >{</span> <span class="token property" >width</span><span class="token punctuation" >:</span> 100px<span class="token punctuation" >;</span> <span class="token punctuation" >}</span>
</code></pre>
<p>Instead of telling the browser which element we want as the container for our query, we add the container query next to the element we want to style different and let the browser decide what the “right” container is. The browser can then traverse the DOM tree up and select the first qualified element as the container.</p>
<p>This could work so: First traverse the DOM up until an element with a fixed width is found, e.g. a pixel value as width or if none is found take the document itself. Then go the DOM from the found element back down as long as the elements depend on the width of the parent e.g. a block element with width auto or a percentage width. Take that element as the container to match the query against.</p>
<p>The recursion example from above would look like this:</p>
<pre><code class="lang-css"><span class="token selector" >.container</span> <span class="token punctuation" >{</span> <span class="token property" >float</span><span class="token punctuation" >:</span> left<span class="token punctuation" >;</span> <span class="token punctuation" >}</span>
<span class="token selector" >.child</span> <span class="token punctuation" >{</span> <span class="token property" >width</span><span class="token punctuation" >:</span> 200px<span class="token punctuation" >;</span> <span class="token punctuation" >}</span>
<span class="token selector" >.child:container(min-width: 150px)</span> <span class="token punctuation" >{</span> <span class="token property" >width</span><span class="token punctuation" >:</span> 100px<span class="token punctuation" >;</span> <span class="token punctuation" >}</span>
</code></pre>
<p>But this time there would be no recursion, because the browser wouldn’t select <code>.container</code> as the container for the query but the parent of <code>.container</code> for example. This wouldn’t only solve the recursion issue but also make more sense for CSS authors who might think of the third rule in the example as like saying <em>“If the child has at least 150 pixel space available horizontally”</em>.</p>
<h2 id="possible-browser-implementation">Possible Browser Implementation</h2>
<p>It would still require that the browser knows the dimensions of the elements while computing the styles, but I think this should be possible without triggering the whole layout process.</p>
<p>If I’m right the browser computes the styles by traversing the DOM tree from top to bottom. In this process it could already calculate and store the width if it knows that it doesn’t depend on its descendants. If it then reaches an element with a container query rule it already knows what the right container is – it’s the nearest ancestor for which it was able to calculate a width – and which width it has.</p>
<p>It may be that I’m totally wrong with my assumptions about browser internals, but it would be great if it is implementable this way.</p>
<h2 id="prolyfill">Prolyfill</h2>
<p>To test my idea I created a prolyfill for my version of container queries, you can find it at <a href="https://github.com/ausi/cq-prolyfill">ausi/cq-prolyfill</a> on GitHub. Feel free to play around with it.</p>
<h2 id="further-ideas">Further ideas</h2>
<p>I wrote here mainly about querying the width and the prolyfill currently only supports width and height. But with my imaginary browser implementation in mind it should be easy to extend container queries to nearly all CSS properties. For example querying the font size or the background color could be helpful to create encapsulated components that look good everywhere. The syntax could be changed to reflect that better like <code>:container(width &gt; 149px)</code> or <code>:container(font-size &lt; 10px)</code>. And most likely there is a better name for the <code>:container(</code> part.</p>
</div>
</article>
<footer class="profile h-card">
<a href="/" class="profile-image">
<img class="u-photo" alt="Martin Auswöger"
srcset="/images/profile-128.jpg 2x"
src="/images/profile-64.jpg"
>
</a>
<h3><a class="u-email p-name" href="mailto:martin@auswoeger.com" rel="me">Martin Auswöger</a></h3>
<p>
@<a class="p-nickname" href="/">ausi</a> on
<a class="u-url" href="https://twitter.com/ausi" rel="me">Twitter</a>,
<a class="u-url" href="https://github.com/ausi" rel="me">GitHub</a> and
<a class="u-url" href="https://stackoverflow.com/users/1031606/ausi" rel="me">Stack Overflow</a>
</p>
</footer>
</div>
</body>
</html>
